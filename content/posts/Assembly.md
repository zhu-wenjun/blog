---
title: "汇编语言"
date: 2019-07-13T17:12:10+08:00
draft: true
---


* 汇编是操纵CPU里寄存器和内存之间数据的语言，时刻不能忘寄存器和内存这2个方面。<br>
* 寄存器由名字进行表示，内存由地址进行表示，寄存器名字和内存地址里面存的都是数据。<br>

# 第一章 基础知识
## 1.1 机器语言与汇编语言
机器语言是机器指令的结合，机器指令是一列二进制数字（由0或1组成），机器指令展开来讲就是CPU可以正确执行的命令。每一种CPU都有自己的机器指令集，即每一种CPU都有自己的机器语言。
早期的程序设计直接使用机器语言。程序员将0或1打在纸带上，1打孔，0不打孔，然后再将程序通过纸带机或卡片机输入计算机。
汇编语言的主体是汇编指令，汇编指令和机器指令的差别在于指令的表示方法上，比如：
操作含义：寄存器BX的内容送到AX中<br>

指令| 表示方法|
:----: |:----:|
机器指令| 1000100111011000|
汇编指令| mov ax,bx|

程序员编写的是汇编指令，但CPU能读懂的是机器指令，所以汇编指令转换到机器指令需要一种叫做编译器的翻译程序<br>
汇编指令 ----> 编译器 ----> 机器指令 ----> 计算机

汇编语言有3种指令：<br>

* 汇编指令： 机器码的助记符，有对应的机器码。<br>
* 伪指令： 没有对应的机器码，由编译器之行，计算机并不执行。<br>
* 其他符号：如+、-、*、/ 等，由编译器识别，没有对应的机器码。<br>

## 1.2 CPU的工作方式

<a id="CPU如何区分指令和数据"/>

想让CPU工作，就需要向CPU提供指令和数据，指令和数据都存储在内存中，CPU从内存中取指令和数据，指令和数据都是二进制数，对CPU来说没有任何区别，但对于程序来说该如何区分呢？

CPU 向外部设备读或写数据时，需要指明3种信息：<br>
**地址信息**：CPU对外部设备读/写的地址，需要地址总线和外部设备交互。地址总线的宽度决定了CPU的寻址能力，比如10根地址总线可以访问0～1023个地址。<br>
**控制信息**：CPU对外部设备读/写的命令，需要控制总线和外部设备交互。控制总线决定了CPU对系统中外部期间的控制能力，比如“读数据信号线”为低时表示CPU要从外部设备读取数据，“写数据信号线”为低时表示CPU要向外部设备写入数据。<br>
**数据信息**：CPU对外部设备读/写的数据，需要数据总线和外部设备交互。数据总线的宽度决定了CPU发送数据的能力，比如8根数据总线一次可以发送1个字节（8位）二进制数，16根数据总线一次可以发送2个字节（16位）二进制数。<br>

![](/asm/1.png "")

BIOS(Basic Input/Output System基本输入输出)，存储在ROM上。
BIOS是由主板和各类接口卡(如显卡、网卡等)厂商提供的软件系统,可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。
例如,主板上的ROM中存储着主板的BIOS(通常称为系统BIOS);显卡上的ROM中存储着显卡的BIOS;如果网卡上装有ROM,那其中就可以存储网卡的BIOS。
某些接口卡需要对大批量输入、输出数据进行暂时存储,在其上装有RAM。典型的是显示卡上的RAM,一般称为显存。显示卡随时将显存中的数据向显
器上输出。换句话说,我们将需要显示的内容写入显存,就会出现在显示器上。

**外部设备，比如显卡，网卡，这些外部设备均具有用来暂存数据的RAM，也有用来存储BIOS（基本输入输出的驱动程序）的ROM。系统会将这些外部设备的RAM/ROM映射到<u>内存</u>上，并在内存中分配好每个RAM/ROM的起始地址和空间大小，CPU通过对内存中的地址进行读写，然后再通过总线将内存中的这些数据写入到外部设备的RAM/ROM中。**
![](/asm/2.png "")

# 第二章 寄存器

一个典型的CPU由运算器、控制器、寄存器(CPU作原理)等器件构成,这些器件靠内部总线相连。前一章所说的总线,相对于CPU内部说是外部总线。<br>
内部总线实现CPU内部各个器件之间的联系,外部总线实现CPU和主板上其他器件的联系。简单地说,在CPU中<br>

* 运算器进行信息处理<br>
* 寄存器进行信息存储<br>
* 控制器控制各种器件进行工作<br>
* 内部总线连接各种器件,在它们之间进行数据的传送。<br>

对于一个汇编程序员来说,CPU中的主要部件是寄存器。寄存器是CPU中程序员可用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制。<br>
不同的CPU,寄存器的个数、结构是不相同的。8086CPU有14个寄存器,每个寄存有一个名称。这些寄存器是:<br>
AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。<br> 
这些寄存器会在使用到的时候一一介绍。<br>

AX、BX、CX、DX 均是16位的通用寄存器，每个寄存器又可以拆分为2个8位的寄存器使用。

16位寄存器| 拆分后高8位| 拆分后低8位|
:----: |:----:|:----:|
AX | AH | AL |
BX | BH | BL |
CX | CH | CL |
DX | DH | DL |

比如AX的寄存器内容为0x58E5，那么AH的值为0x58， AL的值为0xE5.

<br>用汇编指令操纵寄存器的简单介绍<br>

汇编指令 | 控制CPU完成的操作 | 用高级语言的语法描述 |
:----: |:----:|:----:|
mov ax, 18 | 将18送入寄存器AX | AX=18 |
mov ah, 78 | 将78送入寄存器AH | AH=78 |
add ax, 8  | 将寄存器AX中的数值加上8 | AX=AX+8 |
mov ax bx | 将寄存器BX中的数据送入寄存器AX | AX=BX |
add ax bx | 将AX和BX中的数值相加,结果存在AX中 | AX=AX+BX |

**注意⚠️**<br>
1. 寄存器的名字不区分大小写，mov ax, 18和mov AX, 18是一样的。<br>
2. al和ah一样，CPU都拿它们作为独立的8位寄存器来使用。<br>
假设当前al为0x95， add al, 90产生的结果是al = 0x25。虽然0x95 + 0x90 = 0x125, 0x125中的0x25会存储在al中，但0x100不会进位到0xah中，因为它们是2个独立的8位寄存器。<br>
3. 寄存器的操作位数应该是一致的。<br>

操作举例| 是否正确 | 原因|
:----: |:----:|:----:|
mov ax, bx | ✅ | bx和ax位数一致，都是16位 |
mov ah, al | ✅ | al和ah位数一致，都是8位 |
mov ax, al | ❌ |  al和ax位数不一致，al是8位，ax是16位 |
mov ah, 1000 | ❌ | ah作为8位寄存器，最大可存储255的十进制数，1000 > 255，操作有误 |


<br>**CPU寻址方式**<br>
上一节说CPU有运算器、寄存器、控制器和内部总线。<br>
假设当前有一个16位的CPU，那么它一次最多可处理16位的数据，这16位数据的体现在:<br>

* 运算器一次最多可处理16位的数据。
* 寄存器的最大宽度为16位。
* 寄存器和运算器之间的总线通路也为16位。
如果这个CPU的地址总线也为16位，那么它对内存的寻址能力就是2^16 = 65536 Byte = 65536 / 1024 KByte = 64 KByte。<br>

实际上8086CPU就是16位的CPU，但是它的地址总线是20位，8086CPU对内存的寻址能力是2^20 = 1048576 Byte = 1048576 / 1024 KByte = 1024 KByte = 1MByte。<br>
8086是如何在16位CPU的基础上做到20位的内存寻址呢？答案是8086CPU内部有一个“地址加法器”，地址加法器的输入是2个16位的地址，输出是一个20位的地址，所以就有了8086CPU能有20位寻址的方法。

![](/asm/3.png "")
地址加法器输出的 **物理地址 = 基础地址 + 偏移地址 = 段地址x16 + 偏移地址**<br>
段地址和偏移地址都是16位的，段地址 x 16相当于左移4位。<br>

以物理地址21F60H为例，下面表格里的段地址和偏移地址都能通过加法器组成同一个物理地址2160H，这些组合都是合法的。

时间 |周一 |周二 |周三 |周四 |周五 |
:------------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 6:30 ~ 7:30 | 鑫鑫舞蹈 | | | |
| 6:00 ~ 7:00 |          | 红舞鞋英语 | | | |
| 8:30 ~ 9:00 |          |            | 火花思维 | | |
| 6:30 ~ 7:30 |          |            |          | 鑫鑫舞蹈 | |
| 8:30 ~ 9:00 |          |            |          |          | 火花思维 |





时间| 6:30 ~ 7:30 |6:00 ~ 7:00 |8:30 ~ 9:00 |6:30 ~ 7:30|8:30 ~ 9:00 |
:------------:|:--------:|:--------:|:--------:|:--------:|:--------:|
| 周一 | 鑫鑫舞蹈 | | | |
| 周二 |          | 红舞鞋英语 | | | |
| 周三 |          |     科学       | 火花思维 | | |
| 周四 |          |            |          | 鑫鑫舞蹈 | |
| 周五 |          |            |          |          | 火花思维 |


段地址 | 偏移地址 |
:-----:|:--------:|
| 2000H | 1F60H |
| 2100H | 0F60H |
| 2IF0H | 0060H | 
| 21F6H | 0000H |
| 1F00H | 2F60H | 

内存中并没有段的概念，段的产生是因为CPU要访问1M大小的内存，而16位的偏移地址最多只能访问64KB大小的内存地址，要想访问大于64KB的内存地址，便提出了 **段地址x16 + 偏移地址** 的概念，从而形成20位的内存地址。
由于偏移地址最多是64KB（0xFFFF），所以段和段之间的大小不能超过64KB。又因为**基础地址**是**段地址X16**组成的，所以**基础地址**肯定是16的倍数。

8086CPU中有4个段寄存器：**CS（代码段）、DS（数据段）、SS（栈段）、ES**，当CPU要访问内存是，由这4个寄存器提供段地址。<br>

## 2.1 CS 代码段

CS和IP是8086CPU中2个最关键的寄存器，CS是代码段寄存器，IP是指令指针寄存器，它们指示了CPU当前要读取指令的内存地址。<br>
假设CS的内容为m，IP的内容为n，任意时刻CPU将会从CS:IP(意义为：mx16+n)的内存地址上读取一条指令并执行。<br>

![](/asm/4.png "")
(1)8086 CPU 当前状态：CS 中的内容为 2000 H, IP 中的内容为0000 H<br>
(2) 内存 20000~20009 H 单元存放着可执行的机器码<br>
(3) 内存 20000~20009 单元中存放的机器码对应的汇编指令如下:<br>

地址：20000H~20002H，内容：B8 23 01, 长度：3 Byte，对应汇编指令：mov ax,0123 H<br>
地址：20003H~20005H，内容：BB 03 00, 长度：3 Byte，对应汇编指令：mov bx.003 H <br>
地址：20006H~-20007H，内容：89 D8, 长度：2 Byte，对应汇编指令：mov ax, bx <br>
地址：20008H~20009H，内容：01 D8, 长度：2 Byte，对应汇编指令：adax, bx<br>

![](/asm/5.png "")
![](/asm/6.png "")
![](/asm/7.png "")
![](/asm/8.png "")

## 2.2 DS 数据段


前面有个问题, 关于<a href="#CPU如何区分指令和数据">`CPU如何区分指令和数据`</a>，我们知道用CS:IP来告诉CPU这个内存地址上的数据是指令数据，
我们用DS来告诉CPU这个内存地址上的数据就是数据。<br>
8086CPU的汇编指令(mov，sub，add)无法直接将数字赋给段寄存器(CS，DS，SS，ES)，需用一个寄存器进行中转。<br>
比如下面的例子，要把段地址073F赋给ds寄存器，需用一个寄存器(ax)进行中转，直接把073F赋给ds会出错。<br>
[]里的数字表示偏移地址，mov bx,[5]表示把073F:0005内存地址上的数据移到bx寄存器中。<br>

```shell
mov ax,073F
mov ds,ax
mov bx,[5]
```

## 2.3 SS 栈段

# 第三章 DOSBox on Mac

知道了这么多，还不玩点真的？<br>
来，在MAC上搭建DOSBox开发环境。

1.下载[DOSBox](https://www.dosbox.com/download.php?main=1) ，安装并打开，打开后，DOSBox的工作目录默认处于Z盘。
![](/asm/9.jpg "")

2.建立DOSBox的工作目录DOSBox，并挂载到c盘。

```shell
cd ~
mkdir -p ~/work/dosbox
vim ~/Library/Preferences/DOSBox\ 0.74-3\ Preferences
```
在~/Library/Preferences/DOSBox\ 0.74-3\ Preferences文件的最下面加入一行`mount c ~/work/dosbox`的挂载命令，<br>
这样DOSBox启动的时候就会自动挂载c盘<br>

```shell
[autoexec]
# Lines in this section will be run at startup.
# You can put your MOUNT lines here.

mount c ~/work/dosbox
```
3.下载一些DOSBox用到的[工具](https://pan.baidu.com/s/1S4ugB871xW_s0w6U_qCmVA)，然后把这些文件拷贝到~/work/dosbox目录，
当然也会出现在DOSBox挂载的c盘目录。
![](/asm/10.jpg "")

4.在DOSBox里使用debug程序<br>
在DOSBox的c盘下，输入debug并回车，就进入了Debug程序，输入问号❓，即可看到Debug程序里的命令帮助。
![](/asm/11.png "")

Debug主要用的有以下6个命令：<br>
用 Debug 的 R 命令査看、改变 CPU 寄存器的内容<br>
用 Debug 的 D 命令查看内存中的内容<br>
用 Debug 的 E 命令改写内存中的内容<br>
用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令<br>
用 Debug 的 T 命令执行一条机器指令<br>
用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令<br>

<br>**1) <u>命令r的使用</u>**<br>
比如输入命令r，即可查看当前寄存器里的内容，这些寄存器也包括我们认识的AX，BX，CX，DX，CS和IP。
![](/asm/12.png "")
上图最下面的一行：<br>

```shell
073F:0100 0000        ADD     [BX+SI], AL        DS:0000=CD
```
是CS:IP处内存里的机器码（0000）和对应的汇编指令（ADD [BX+SI,AL]）和后面的DS:0000=CD，这些指令的意思我们先不必深究，后面会讲到。<br>


用r命令修改AX寄存器的值<br>
![](/asm/13.png "")

<br>**2) <u>命令d的使用</u>**<br>
用d命令查看CS:IP内存的值。<br>
每一行均显示16个字节的数据，比如第1行是从073F:0100 ~ 073F:000F，第2行是从073F:0110 ~ 073F:001F。<br>
每一行最右面的部分代表16个字节对应的[ASCII码](https://zh.wikipedia.org/wiki/ASCII)，比如第2行最右面的`............4...`。<br>
`.`代表这个字节没有对应的ASCII码，`34H`对应的ASCII码是`4`。<br>
![](/asm/14.png "")


<br>**3) <u>命令e的使用</u>**<br>
把073F:0100内存地址起始的数据改成0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 对应的ASCII码是ABCDEF。<br>
![](/asm/15.png "")

<br>**4) <u>命令u的使用</u>**<br>
使用u命令读取073F:0100内存地址里机器指令对应的汇编指令，比如机器指令B80100对应的汇编指令是MOV AX,0001。<br>
![](/asm/16.png "")

<br>**5) <u>命令t的使用</u>**<br>
命令t执行CS:IP内存地址里的数据，比如下图执行t命令后，AX的内容从0x0110变为了0x0001。
![](/asm/17.png "")


<br>**6) <u>命令a的使用</u>**<br>
命令a用于向内存地址写入汇编指令，比如下图用a命令向073F:0100处写入汇编命令MOV AX,0009,然后再用d命令查看073F:0100处的数据，机器指令为B80900。<br>
![](/asm/18.png "")
